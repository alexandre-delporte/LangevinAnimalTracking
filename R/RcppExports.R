# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

solve_ODE_cpp <- function(U, delta, push, potential_params, ind_fixed_point) {
    .Call(`_LangevinAnimalTracking_solve_ODE_cpp`, U, delta, push, potential_params, ind_fixed_point)
}

#' Run particle filter algorithm for the Langevin diffusion with specified measurement errors
#' and splitting schemes
#' 
#' @param observations Matrix with dimensions N x 3: time, Y1, Y2
#' @param sde_params List with elements: tau (persistence), nu (velocity scale), omega (rotation)
#' @param potential_params List with elements:
#'   \itemize{
#'     \item alpha: Numeric vector of mixture weights
#'     \item B: List of precision matrices
#'     \item x_star: Matrix of fixed point coordinates
#'   }
#' @param error_params List of parameters for the measurement error distribution (contents depend on error_dist):
#'   \itemize{
#'     \item For "normal": sigma_obs (observation error standard deviation)
#'     \item For "scaled_t": scale and df (degrees of freedom)
#'     \item For "argos": sigma_obs, df, rho, a, p
#'   }
#' @param error_dist String specifying error distribution: "normal", "scaled_t", or "argos"
#' @param polygon_coords Matrix of polygon boundary coordinates (N x 2)
#' @param U0 Numeric vector of initial state (length 4: position and velocity)
#' @param lambda Numeric, penalization parameter (positive number, Inf for no penalization)
#' @param num_particles Integer, number of particles to use in the filter
#' @param scheme String, splitting scheme: "Lie-Trotter" or "Strang"
#' @param split_around_fixed_point Logical, whether to split around fixed points
#' @param ESS_threshold Numeric between 0 and 1, threshold on effective sample size for resampling
#' @param proposal_weight Numeric between 0 and 1, weight attributed to the previous state in the Gaussian proposal
#' @param verbose Logical, whether to print progress messages
#' @param print_timing Logical, whether to print profiling timing results (default: FALSE)
#' 
#' @return List with elements:
#'   \itemize{
#'     \item particles: Array of particles (num_particles x 4 x N)
#'     \item weights: Matrix of normalized weights (num_particles x N)
#'     \item total_weights: Vector of sum of unnormalized weights at each time step
#'     \item loglik: Estimated log-likelihood
#'     \item loglik_vector: Estimated log-likelihood at each time step
#'     \item push: Array of inward pushes for each particle at each time step
#'     \item ancestors: Matrix of ancestor indices
#'     \item resampled_at: Logical vector indicating steps where resampling was performed
#'     \item ess_history: Vector of ESS at each time step
#'     \item timing: List of timing information for code profiling
#'     \item ind_fixed_point: (if split_around_fixed_point=TRUE) Matrix of fixed point indices
#'   }
#' @export
particle_filter2D_cpp <- function(observations, sde_params, potential_params, error_params, error_dist, polygon_coords, U0, lambda, num_particles, scheme, split_around_fixed_point, ESS_threshold, proposal_weight, verbose, print_timing) {
    .Call(`_LangevinAnimalTracking_particle_filter2D_cpp`, observations, sde_params, potential_params, error_params, error_dist, polygon_coords, U0, lambda, num_particles, scheme, split_around_fixed_point, ESS_threshold, proposal_weight, verbose, print_timing)
}

#' Compute exact covariance matrix for Ornstein-Uhlenbeck process (C++ version)
#' 
#' @param A Drift matrix (d x d)
#' @param Gamma Process covariance matrix (d x d)
#' @param h Time step
#' @param expAh Matrix exponential exp(A*h) (d x d)
#' @return Covariance matrix Q (d x d)
#' @export
OU_cov_exact_cpp <- function(A, Gamma, h, expAh) {
    .Call(`_LangevinAnimalTracking_OU_cov_exact_cpp`, A, Gamma, h, expAh)
}

#' Compute exact covariance matrix with matrix exponential computed internally
#' 
#' @param A Drift matrix (d x d)
#' @param Gamma Process covariance matrix (d x d)
#' @param h Time step
#' @return Covariance matrix Q (d x d)
#' @export
OU_cov_exact_cpp_full <- function(A, Gamma, h) {
    .Call(`_LangevinAnimalTracking_OU_cov_exact_cpp_full`, A, Gamma, h)
}

#' Compute the covariance matrix for the RACVM model (C++ version)
#' 
#' Computes the exact covariance matrix for the Rotational Advective 
#' Correlated Velocity Model (RACVM) used in animal movement modeling.
#' 
#' @param tau Time scale parameter (persistence)
#' @param nu Scale parameter (velocity magnitude)
#' @param omega Angular velocity parameter (rotation)
#' @param dt Time step
#' @return Covariance matrix Q (4x4 matrix)
#' @export
RACVM_cov_cpp <- function(tau, nu, omega, dt) {
    .Call(`_LangevinAnimalTracking_RACVM_cov_cpp`, tau, nu, omega, dt)
}

#' Compute RACVM link matrix (C++ version)
#' 
#' Computes the state transition matrix for the RACVM model.
#' 
#' @param tau Time scale parameter
#' @param omega Angular velocity parameter
#' @param dt Time step
#' @return Link matrix L (4x4 matrix)
#' @export
RACVM_link_cpp <- function(tau, omega, dt) {
    .Call(`_LangevinAnimalTracking_RACVM_link_cpp`, tau, omega, dt)
}

#'
#' Computes the SDE flow for one time step of the splitting scheme, 
#' either naively or around a fixed point of a Gaussian mixture potential.
#'
#' @param U Numeric vector of length 4 (x1, x2, v1, v2)
#' @param delta Time step size
#' @param tau Correlation timescale parameter
#' @param nu Velocity scale parameter
#' @param omega Rotation parameter
#' @param potential_params List with elements a:
#' alpha Numeric vector of mixture weights (empty if not using fixed point)
#' B_list List of precision matrices (empty if not using fixed point)
#' x_star Matrix of fixed point coordinates (empty if not using fixed point)
#' @param ind_fixed_point Index of fixed point (1-based)
#' @param L_provided Optional pre-computed link matrix (4x4, empty matrix if not provided)
#' @param Q_provided Optional pre-computed covariance matrix (4x4, empty matrix if not provided)
#' @return List with 'mean' (length 4) and 'Q' (4x4 matrix)
#' @export
solve_SDE_cpp <- function(U, delta, tau, nu, omega, potential_params, ind_fixed_point, L_provided, Q_provided) {
    .Call(`_LangevinAnimalTracking_solve_SDE_cpp`, U, delta, tau, nu, omega, potential_params, ind_fixed_point, L_provided, Q_provided)
}

mix_gaussian_grad_cpp <- function(x, x_star, params, exclude) {
    .Call(`_LangevinAnimalTracking_mix_gaussian_grad_cpp`, x, x_star, params, exclude)
}

log_dmvnorm_chol_cpp <- function(x, mean, cholSigma) {
    .Call(`_LangevinAnimalTracking_log_dmvnorm_chol_cpp`, x, mean, cholSigma)
}

#' Product of Two Gaussian Distributions
#'
#' Computes the mean and covariance of the product of two Gaussian densities:
#' \deqn{N(mean1, P1^{-1}) \times N(L mean2, P2^{-1}) \propto N(m, \Gamma).}
#'
#' @param P1 Precision matrix (inverse covariance) of dimension \eqn{n \times n}.
#' @param P2 Precision matrix (inverse covariance) of dimension \eqn{q \times q}.
#' @param mean1 Numeric vector of length \eqn{n}. Mean of the first Gaussian.
#' @param mean2 Numeric vector of length \eqn{q}. Mean of the second Gaussian.
#' @param L Link matrix of dimension \eqn{q \times n} that maps the state space.
#'
#' @return A list with components:
#' \describe{
#'   \item{\code{mean}}{Posterior mean vector.}
#'   \item{\code{cov}}{Posterior covariance matrix.}
#'   \item{\code{chol}}{Upper triangular Cholesky factor of covariance matrix,
#'     where \code{cov = t(chol) \%*\% chol} (matching R's \code{chol()} convention).}
#' }
#'
#' @export
product_gaussian_cpp <- function(P1, P2, mean1, mean2, M, proposal_weight) {
    .Call(`_LangevinAnimalTracking_product_gaussian_cpp`, P1, P2, mean1, mean2, M, proposal_weight)
}

chol_cpp <- function(Q) {
    .Call(`_LangevinAnimalTracking_chol_cpp`, Q)
}

chol2inv_cpp <- function(R) {
    .Call(`_LangevinAnimalTracking_chol2inv_cpp`, R)
}

choose_center_cpp <- function(x, x_star, params) {
    .Call(`_LangevinAnimalTracking_choose_center_cpp`, x, x_star, params)
}

choose_center_matrix_cpp <- function(X, x_star, params) {
    .Call(`_LangevinAnimalTracking_choose_center_matrix_cpp`, X, x_star, params)
}

closest_point_on_boundary_cpp <- function(x, coords, grad) {
    .Call(`_LangevinAnimalTracking_closest_point_on_boundary_cpp`, x, coords, grad)
}

compute_push_cpp <- function(x, coords, lambda) {
    .Call(`_LangevinAnimalTracking_compute_push_cpp`, x, coords, lambda)
}

compute_push_matrix_cpp <- function(X, coords, lambda) {
    .Call(`_LangevinAnimalTracking_compute_push_matrix_cpp`, X, coords, lambda)
}

dscaledt_cpp <- function(y, mean, scale, df, logp) {
    .Call(`_LangevinAnimalTracking_dscaledt_cpp`, y, mean, scale, df, logp)
}

dmvt_mixture_cpp <- function(x, mean, params, logp) {
    .Call(`_LangevinAnimalTracking_dmvt_mixture_cpp`, x, mean, params, logp)
}

